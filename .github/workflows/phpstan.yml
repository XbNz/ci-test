name: PHPStan

on:
  pull_request:
    types: [opened, reopened, synchronize, closed]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  phpstan:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - name: pr-tip
            ref: ${{ github.head_ref }}
          - name: target-branch
            ref: ${{ github.event.pull_request.base.ref }}
    outputs:
      pr-tip-phpstan-json: ${{ steps.emit-pr-tip-json.outputs.pr-tip-json }}
      target-branch-phpstan-json: ${{ steps.emit-target-json.outputs.target-branch-json }}
    steps:
      - name: Checkout code (${{ matrix.name }})
        uses: actions/checkout@v4
        with:
          ref: ${{ matrix.ref }}
      - name: Set up Herd Lite (PHP 8.3)
        env:
          TERM: xterm
          PHP_VERSION: 8.3
        run: |
          curl -sSL https://php.new/install/linux | bash
      - name: Add Herd binaries to PATH
        run: echo "$HOME/.config/herd-lite/bin" >> $GITHUB_PATH
      - name: Get Composer cache directory
        id: composer-cache
        run: |
          echo "directory=$(composer config --absolute cache-files-dir)" >> $GITHUB_OUTPUT
      - name: Restore Composer & vendor cache
        uses: actions/cache@v4
        with:
          path: |
            ${{ steps.composer-cache.outputs.directory }}
            vendor
          key: ${{ runner.os }}-composer-${{ hashFiles('**/composer.lock') }}
          restore-keys: |
            ${{ runner.os }}-composer-
      - name: Install dependencies
        run: |
          composer install \
            --prefer-dist \
            --no-progress \
            --no-interaction \
            --no-scripts
      - name: Restore PHPStan result cache
        uses: actions/cache@v4
        with:
          path: tmp
          key: phpstan-result-cache-${{ github.run_id }}
          restore-keys: |
            phpstan-result-cache-
      - name: Run PHPStan and produce JSON
        id: run-phpstan
        run: |
          php vendor/bin/phpstan analyze \
            --memory-limit=2G \
            --configuration=phpstan.neon \
            --error-format=json \
            > phpstan-output.json || true
      - name: Save PHPStan cache
        uses: actions/cache@v4
        if: ${{ !cancelled() }}
        with:
          path: tmp
          key: phpstan-result-cache-${{ github.run_id }}
      - name: Emit pr-tip output
        id: emit-pr-tip-json
        if: ${{ matrix.name == 'pr-tip' }}
        run: |
          ONE_LINE_JSON=$(jq -c . phpstan-output.json)
          echo "pr-tip-json=$ONE_LINE_JSON" >> $GITHUB_OUTPUT
      - name: Emit target-branch output
        id: emit-target-json
        if: ${{ matrix.name == 'target-branch' }}
        run: |
          ONE_LINE_JSON=$(jq -c . phpstan-output.json)
          echo "target-branch-json=$ONE_LINE_JSON" >> $GITHUB_OUTPUT

  compare-results:
    needs: phpstan
    runs-on: ubuntu-latest
    steps:
      - name: Generate introduced-errors.json
        run: |
          jq -s '
            # 1) Build a unique key per error by joining its 4 identifying fields:
            def err_id:
              [.message, (.line|tostring), (.ignorable|tostring), .identifier]
              | join("|");

            # 2) Turn ‚Äúfiles ‚Üí messages‚Äù into a map { key: fullErrorObj },
            #    and inject the ‚Äúfile‚Äù path into each error:
            def to_map(obj):
              obj.files
              | to_entries
              | map(
                  . as $f
                  | (
                      # take this file‚Äôs messages and add { file: <path> } to each
                      $f.value.messages
                      | map(. + { file: $f.key })
                    )
                )
              | add                      # flatten into one big array of errors
              | map({ (err_id): . })     # wrap each error as { "<joined-string>": errorObj }
              | add;                     # merge into one object

            # 3) Extract all keys from a map as a string array:
            def my_keys(m):
              m | to_entries | map(.key);

            # 4) Slurp both JSON inputs into [$pr, $target]:
            . as [$pr, $target]

            # 5) Build two maps (keyed by our ‚Äújoined-string‚Äù):
            | (to_map($pr))     as $pr_map
            | (to_map($target)) as $tgt_map

            # 6) Keys in pr_map but not in tgt_map ‚Üí newly introduced errors:
            | [ ( my_keys($pr_map) - my_keys($tgt_map) )[]
                | $pr_map[.] ]
          ' <<EOF > introduced-errors.json
          ${{ needs.phpstan.outputs.pr-tip-phpstan-json }}
          ${{ needs.phpstan.outputs.target-branch-phpstan-json }}
          EOF

      - name: Generate removed-errors.json
        run: |
          jq -s '
            def err_id:
              [.message, (.line|tostring), (.ignorable|tostring), .identifier]
              | join("|");

            def to_map(obj):
              obj.files
              | to_entries
              | map(
                  . as $f
                  | (
                      $f.value.messages
                      | map(. + { file: $f.key })
                    )
                )
              | add
              | map({ (err_id): . })
              | add;

            def my_keys(m):
              m | to_entries | map(.key);

            . as [$pr, $target]
            | (to_map($pr))     as $pr_map
            | (to_map($target)) as $tgt_map

            # Keys in tgt_map but not in pr_map ‚Üí removed-in-pr errors:
            | [ ( my_keys($tgt_map) - my_keys($pr_map) )[]
                | $tgt_map[.] ]
          ' <<EOF > removed-errors.json
          ${{ needs.phpstan.outputs.pr-tip-phpstan-json }}
          ${{ needs.phpstan.outputs.target-branch-phpstan-json }}
          EOF

      - name: Show summary of deltas
        run: |
          echo "Introduced files/errors:"
          jq . introduced-errors.json || true
          echo
          echo "Removed files/errors:"
          jq . removed-errors.json || true

      - name: Build PR comment Markdown
        id: build-comment
        run: |
          cat introduced-errors.json
          cat removed-errors.json
          #
          # Check if introduced-errors.json is empty:
          #
          if [ "$(jq 'length' introduced-errors.json)" -eq 0 ]; then
            INTRO_TABLE="_No errors found! üéâ_"
          else
            # Produce Markdown rows directly from introduced-errors.json
            INTRO_TABLE=$(
              {
                echo "| File | Line | Message |"
                echo "| ---- | ----: | ------- |"
                jq -r '
                  .[]
                  | "| \(.file|gsub("\\|";"\\\\|")) | \(.line) | \(.message|gsub("\\|";"\\\\|")) |"
                ' introduced-errors.json
              }
            )
          fi

          #
          # Check if removed-errors.json is empty:
          #
          if [ "$(jq 'length' removed-errors.json)" -eq 0 ]; then
            REMOVED_TABLE="_No errors found! üéâ_"
          else
            REMOVED_TABLE=$(
              {
                echo "| File | Line | Message |"
                echo "| ---- | ----: | ------- |"
                jq -r '
                  .[]
                  | "| \(.file|gsub("\\|";"\\\\|")) | \(.line) | \(.message|gsub("\\|";"\\\\|")) |"
                ' removed-errors.json
              }
            )
          fi

          #
          # Write out the comment body in markdown:
          #
          {
            echo "<!-- phpstan-comment -->"
            echo ""
            echo "# PHPStan Analysis Results"
            echo ""
            echo "## ‚ùå Introduced Errors"
            echo ""
            printf "%s\n" "$INTRO_TABLE"
            echo ""
            echo "---"
            echo ""
            echo "## ‚úÖ Removed Errors"
            echo ""
            printf "%s\n" "$REMOVED_TABLE"
          } > phpstan-comment.md

          echo "comment-file=phpstan-comment.md" >> $GITHUB_OUTPUT

      - name: Create or update PHPStan comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const body = fs.readFileSync('phpstan-comment.md', 'utf8');
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              per_page: 100
            });
            const marker = '<!-- phpstan-comment -->';
            const existing = comments.find(c => c.body.includes(marker));
            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }
